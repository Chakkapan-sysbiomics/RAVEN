<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of getINITModel</title>
  <meta name="keywords" content="getINITModel">
  <meta name="description" content="getINITModel">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../index.html">Home</a> &gt;  <a href="index.html">INIT</a> &gt; getINITModel.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../index.html"><img alt="<" border="0" src="../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for INIT&nbsp;<img alt=">" border="0" src="../right.png"></a></td></tr></table>-->

<h1>getINITModel
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>getINITModel</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function [model, metProduction, essentialRxnsForTasks, addedRxnsForTasks, deletedDeadEndRxns, deletedRxnsInINIT, taskReport]=getINITModel(refModel, tissue, celltype, hpaData, arrayData, metabolomicsData, taskFile, useScoresForTasks, printReport, taskStructure, params, paramsFT) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment"> getINITModel
   Generates a model using the INIT algorithm, based on proteomics and/or
   transcriptomics and/or metabolomics and/or metabolic tasks.

   Input:
   refModel            a model structure. The model should be in the
                       closed form (no exchange reactions open). Import
                       using import(filename,false). If the model is not
                       loaded using importModel, it might be that there
                       is no &quot;unconstrained&quot; field. In that case,
                       manually add the field like:
                       model.unconstrained=false(numel(model.mets),1);
   tissue              tissue to score for. Should exist in either
                       hpaData.tissues or arrayData.tissues
   celltype            cell type to score for. Should exist in either
                       hpaData.celltypes or arrayData.celltypes for this
                       tissue (opt, default is to use the best values
                       among all the cell types for the tissue. Use [] if
                       you want to supply more arguments)
   hpaData             HPA data structure from parseHPA (opt if arrayData is
                       supplied, default [])
   arrayData           gene expression data structure (opt if hpaData is
                       supplied, default [])
       genes           cell array with the unique gene names
       tissues         cell array with the tissue names. The list may not be
                       unique, as there can be multiple cell types per tissue
       celltypes       cell array with the cell type names for each tissue
       levels          GENESxTISSUES array with the expression level for
                       each gene in each tissue/celltype. NaN should be
                       used when no measurement was performed
       threshold       a single value or a vector of gene expression 
                       thresholds, above which genes are considered to be
                       &quot;expressed&quot;. (opt, by default, the mean expression
                       levels of each gene across all tissues in arrayData
                       will be used as the threshold values)
       singleCells     binary value selecting whether to use the
                       single-cell algorithm to identify expressed genes.
                       If used, specify cell subpopulations in CELLTYPES
                       (opt, default [])
       plotResults     true if single cell probability distributions
                       should be plotted (opt, default = False)
   metabolomicsData    cell array with metabolite names that the model
                       should produce (opt, default [])
   taskFile            a task list in Excel format. See parseTaskList for
                       details (opt, default [])
   useScoresForTasks   true if the calculated reaction scored should be used as
                       weights in the fitting to tasks (opt, default true)
   printReport         true if a report should be printed to the screen
                       (opt, default true)
   taskStructure       task structure as from parseTaskList. Can be used
                       as an alternative way to define tasks when Excel
                       sheets are not suitable. Overrides taskFile (opt,
                       default [])
   params              parameter structure as used by getMILPParams. This is
                       for the INIT algorithm. For the the MILP problems
                       solved to fit tasks, see paramsFT (opt, default [])
   paramsFT            parameter structure as used by getMILPParams. This is
                       for the fitTasks step. For the INIT algorithm, see
                       params (opt, default [])


   Output:
   model                   the resulting model structure
   metProduction           array that indicates which of the
                           metabolites in metabolomicsData that could be
                           produced. Note that this is before the
                           gap-filling process to enable defined tasks. To
                           see which metabolites that can be produced in
                           the final model, use canProduce.
                           -2: metabolite name not found in model
                           -1: metabolite found, but it could not be produced
                           1: metabolite could be produced
   essentialRxnsForTasks   cell array of the reactions which were
                           essential to perform the tasks
   addedRxnsForTasks       cell array of the reactions which were added in
                           order to perform the tasks
   deletedDeadEndRxns      cell array of reactions deleted because they
                           could not carry flux (INIT requires a
                           functional input model)
   deletedRxnsInINIT       cell array of the reactions which were deleted by
                           the INIT algorithm
   taskReport              structure with the results for each task
       id                  cell array with the id of the task
       description         cell array with the description of the task
       ok                  boolean array with true if the task was successful
       essential           cell array with cell arrays of essential
                           reactions for the task
       gapfill             cell array of cell arrays of reactions included
                           in the gap-filling for the task

   This is the main function for automatic reconstruction of models based
   on the (t)INIT algorithm (PLoS Comput Biol. 2012;8(5):e1002518, 
   Mol Syst Biol. 2014;10:721). Not all settings are possible using this
   function, and you may want to call the functions scoreModel, runINIT
   and fitTasks individually instead.

   NOTE: Exchange metabolites should normally not be removed from the model
   when using this approach, since checkTasks/fitTasks rely on putting specific
   constraints for each task. The INIT algorithm will remove exchange metabolites
   if any are present. Use importModel(file,false) to import a model with
   exchange metabolites remaining.

   Usage: [model, metProduction, essentialRxnsForTasks, addedRxnsForTasks,...
               deletedDeadEndRxns, deletedRxnsInINIT, taskReport]=...
               getINITModel(refModel, tissue, celltype, hpaData, arrayData,...
               metabolomicsData, taskFile, useScoresForTasks, printReport,...
               taskStructure, params, paramsFT)</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="runINIT.html" class="code" title="function [outModel, deletedRxns, metProduction, fValue]=runINIT(model,rxnScores,presentMets,essentialRxns,prodWeight,allowExcretion,noRevLoops,params)">runINIT</a>	runINIT</li></ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
</ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="#_sub1" class="code">function [rxnS, geneS]=printScores(model,name,hpaData,arrayData,tissue,celltype)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [model, metProduction, essentialRxnsForTasks, addedRxnsForTasks, deletedDeadEndRxns, deletedRxnsInINIT, taskReport]=getINITModel(refModel, tissue, celltype, hpaData, arrayData, metabolomicsData, taskFile, useScoresForTasks, printReport, taskStructure, params, paramsFT)</a>
0002 <span class="comment">% getINITModel</span>
0003 <span class="comment">%   Generates a model using the INIT algorithm, based on proteomics and/or</span>
0004 <span class="comment">%   transcriptomics and/or metabolomics and/or metabolic tasks.</span>
0005 <span class="comment">%</span>
0006 <span class="comment">%   Input:</span>
0007 <span class="comment">%   refModel            a model structure. The model should be in the</span>
0008 <span class="comment">%                       closed form (no exchange reactions open). Import</span>
0009 <span class="comment">%                       using import(filename,false). If the model is not</span>
0010 <span class="comment">%                       loaded using importModel, it might be that there</span>
0011 <span class="comment">%                       is no &quot;unconstrained&quot; field. In that case,</span>
0012 <span class="comment">%                       manually add the field like:</span>
0013 <span class="comment">%                       model.unconstrained=false(numel(model.mets),1);</span>
0014 <span class="comment">%   tissue              tissue to score for. Should exist in either</span>
0015 <span class="comment">%                       hpaData.tissues or arrayData.tissues</span>
0016 <span class="comment">%   celltype            cell type to score for. Should exist in either</span>
0017 <span class="comment">%                       hpaData.celltypes or arrayData.celltypes for this</span>
0018 <span class="comment">%                       tissue (opt, default is to use the best values</span>
0019 <span class="comment">%                       among all the cell types for the tissue. Use [] if</span>
0020 <span class="comment">%                       you want to supply more arguments)</span>
0021 <span class="comment">%   hpaData             HPA data structure from parseHPA (opt if arrayData is</span>
0022 <span class="comment">%                       supplied, default [])</span>
0023 <span class="comment">%   arrayData           gene expression data structure (opt if hpaData is</span>
0024 <span class="comment">%                       supplied, default [])</span>
0025 <span class="comment">%       genes           cell array with the unique gene names</span>
0026 <span class="comment">%       tissues         cell array with the tissue names. The list may not be</span>
0027 <span class="comment">%                       unique, as there can be multiple cell types per tissue</span>
0028 <span class="comment">%       celltypes       cell array with the cell type names for each tissue</span>
0029 <span class="comment">%       levels          GENESxTISSUES array with the expression level for</span>
0030 <span class="comment">%                       each gene in each tissue/celltype. NaN should be</span>
0031 <span class="comment">%                       used when no measurement was performed</span>
0032 <span class="comment">%       threshold       a single value or a vector of gene expression</span>
0033 <span class="comment">%                       thresholds, above which genes are considered to be</span>
0034 <span class="comment">%                       &quot;expressed&quot;. (opt, by default, the mean expression</span>
0035 <span class="comment">%                       levels of each gene across all tissues in arrayData</span>
0036 <span class="comment">%                       will be used as the threshold values)</span>
0037 <span class="comment">%       singleCells     binary value selecting whether to use the</span>
0038 <span class="comment">%                       single-cell algorithm to identify expressed genes.</span>
0039 <span class="comment">%                       If used, specify cell subpopulations in CELLTYPES</span>
0040 <span class="comment">%                       (opt, default [])</span>
0041 <span class="comment">%       plotResults     true if single cell probability distributions</span>
0042 <span class="comment">%                       should be plotted (opt, default = False)</span>
0043 <span class="comment">%   metabolomicsData    cell array with metabolite names that the model</span>
0044 <span class="comment">%                       should produce (opt, default [])</span>
0045 <span class="comment">%   taskFile            a task list in Excel format. See parseTaskList for</span>
0046 <span class="comment">%                       details (opt, default [])</span>
0047 <span class="comment">%   useScoresForTasks   true if the calculated reaction scored should be used as</span>
0048 <span class="comment">%                       weights in the fitting to tasks (opt, default true)</span>
0049 <span class="comment">%   printReport         true if a report should be printed to the screen</span>
0050 <span class="comment">%                       (opt, default true)</span>
0051 <span class="comment">%   taskStructure       task structure as from parseTaskList. Can be used</span>
0052 <span class="comment">%                       as an alternative way to define tasks when Excel</span>
0053 <span class="comment">%                       sheets are not suitable. Overrides taskFile (opt,</span>
0054 <span class="comment">%                       default [])</span>
0055 <span class="comment">%   params              parameter structure as used by getMILPParams. This is</span>
0056 <span class="comment">%                       for the INIT algorithm. For the the MILP problems</span>
0057 <span class="comment">%                       solved to fit tasks, see paramsFT (opt, default [])</span>
0058 <span class="comment">%   paramsFT            parameter structure as used by getMILPParams. This is</span>
0059 <span class="comment">%                       for the fitTasks step. For the INIT algorithm, see</span>
0060 <span class="comment">%                       params (opt, default [])</span>
0061 <span class="comment">%</span>
0062 <span class="comment">%</span>
0063 <span class="comment">%   Output:</span>
0064 <span class="comment">%   model                   the resulting model structure</span>
0065 <span class="comment">%   metProduction           array that indicates which of the</span>
0066 <span class="comment">%                           metabolites in metabolomicsData that could be</span>
0067 <span class="comment">%                           produced. Note that this is before the</span>
0068 <span class="comment">%                           gap-filling process to enable defined tasks. To</span>
0069 <span class="comment">%                           see which metabolites that can be produced in</span>
0070 <span class="comment">%                           the final model, use canProduce.</span>
0071 <span class="comment">%                           -2: metabolite name not found in model</span>
0072 <span class="comment">%                           -1: metabolite found, but it could not be produced</span>
0073 <span class="comment">%                           1: metabolite could be produced</span>
0074 <span class="comment">%   essentialRxnsForTasks   cell array of the reactions which were</span>
0075 <span class="comment">%                           essential to perform the tasks</span>
0076 <span class="comment">%   addedRxnsForTasks       cell array of the reactions which were added in</span>
0077 <span class="comment">%                           order to perform the tasks</span>
0078 <span class="comment">%   deletedDeadEndRxns      cell array of reactions deleted because they</span>
0079 <span class="comment">%                           could not carry flux (INIT requires a</span>
0080 <span class="comment">%                           functional input model)</span>
0081 <span class="comment">%   deletedRxnsInINIT       cell array of the reactions which were deleted by</span>
0082 <span class="comment">%                           the INIT algorithm</span>
0083 <span class="comment">%   taskReport              structure with the results for each task</span>
0084 <span class="comment">%       id                  cell array with the id of the task</span>
0085 <span class="comment">%       description         cell array with the description of the task</span>
0086 <span class="comment">%       ok                  boolean array with true if the task was successful</span>
0087 <span class="comment">%       essential           cell array with cell arrays of essential</span>
0088 <span class="comment">%                           reactions for the task</span>
0089 <span class="comment">%       gapfill             cell array of cell arrays of reactions included</span>
0090 <span class="comment">%                           in the gap-filling for the task</span>
0091 <span class="comment">%</span>
0092 <span class="comment">%   This is the main function for automatic reconstruction of models based</span>
0093 <span class="comment">%   on the (t)INIT algorithm (PLoS Comput Biol. 2012;8(5):e1002518,</span>
0094 <span class="comment">%   Mol Syst Biol. 2014;10:721). Not all settings are possible using this</span>
0095 <span class="comment">%   function, and you may want to call the functions scoreModel, runINIT</span>
0096 <span class="comment">%   and fitTasks individually instead.</span>
0097 <span class="comment">%</span>
0098 <span class="comment">%   NOTE: Exchange metabolites should normally not be removed from the model</span>
0099 <span class="comment">%   when using this approach, since checkTasks/fitTasks rely on putting specific</span>
0100 <span class="comment">%   constraints for each task. The INIT algorithm will remove exchange metabolites</span>
0101 <span class="comment">%   if any are present. Use importModel(file,false) to import a model with</span>
0102 <span class="comment">%   exchange metabolites remaining.</span>
0103 <span class="comment">%</span>
0104 <span class="comment">%   Usage: [model, metProduction, essentialRxnsForTasks, addedRxnsForTasks,...</span>
0105 <span class="comment">%               deletedDeadEndRxns, deletedRxnsInINIT, taskReport]=...</span>
0106 <span class="comment">%               getINITModel(refModel, tissue, celltype, hpaData, arrayData,...</span>
0107 <span class="comment">%               metabolomicsData, taskFile, useScoresForTasks, printReport,...</span>
0108 <span class="comment">%               taskStructure, params, paramsFT)</span>
0109 
0110 <span class="keyword">if</span> nargin&lt;3
0111     celltype=[];
0112 <span class="keyword">end</span>
0113 <span class="keyword">if</span> nargin&lt;4
0114     hpaData=[];
0115 <span class="keyword">end</span>
0116 <span class="keyword">if</span> nargin&lt;5
0117     arrayData=[];
0118 <span class="keyword">end</span>
0119 <span class="keyword">if</span> nargin&lt;6
0120     metabolomicsData=[];
0121 <span class="keyword">end</span>
0122 <span class="keyword">if</span> nargin&lt;7
0123     taskFile=[];
0124 <span class="keyword">end</span>
0125 <span class="keyword">if</span> nargin&lt;8 || isempty(useScoresForTasks)
0126     useScoresForTasks=true;
0127 <span class="keyword">end</span>
0128 <span class="keyword">if</span> nargin&lt;9 || isempty(printReport)
0129     printReport=true;
0130 <span class="keyword">end</span>
0131 <span class="keyword">if</span> nargin&lt;10
0132     taskStructure=[];
0133 <span class="keyword">end</span>
0134 <span class="keyword">if</span> nargin&lt;11
0135     params=[];
0136 <span class="keyword">end</span>
0137 <span class="keyword">if</span> nargin&lt;12
0138     paramsFT=[];
0139 <span class="keyword">end</span>
0140 
0141 <span class="comment">%Check that the model is in the closed form</span>
0142 <span class="keyword">if</span> ~isfield(refModel,<span class="string">'unconstrained'</span>)
0143     EM=<span class="string">'Exchange metabolites should normally not be removed from the model when using getINITModel. Use importModel(file,false) to import a model with exchange metabolites remaining (see the documentation for details)'</span>;
0144     dispEM(EM);
0145 <span class="keyword">end</span>
0146 
0147 <span class="comment">%Create the task structure if not supplied</span>
0148 <span class="keyword">if</span> any(taskFile) &amp;&amp; isempty(taskStructure)
0149     taskStructure=parseTaskList(taskFile);
0150 <span class="keyword">end</span>
0151 
0152 
0153 <span class="comment">% sc-tINIT to identify confidence levels of gene expression</span>
0154 <span class="keyword">if</span> ~isempty(arrayData) &amp;&amp; isfield(arrayData,<span class="string">'singleCells'</span>)
0155     <span class="keyword">if</span> arrayData.singleCells == 1
0156         <span class="comment">% Check to ensure cell type is defined</span>
0157         <span class="keyword">if</span> ~isfield(arrayData,<span class="string">'celltypes'</span>)
0158             dispEM(<span class="string">'arrayData must contain cell type information if sc-tINIT is to be used'</span>,<span class="string">'false'</span>);   
0159         <span class="keyword">end</span>
0160         <span class="keyword">if</span> ~ismember(upper(celltype),upper(arrayData.celltypes))
0161             dispEM(<span class="string">'The cell type name does not match'</span>);   
0162         <span class="keyword">end</span>
0163         
0164         <span class="comment">% Analyze only cell type of interest</span>
0165         J= strcmpi(arrayData.celltypes,celltype);
0166         
0167         <span class="comment">% Analyze only genes included in the reference model</span>
0168         I=ismember(arrayData.genes,refModel.genes);
0169         
0170         <span class="comment">% Convert expression data to population fractions</span>
0171         binary_levels = arrayData.levels(I,J)~=0; <span class="comment">% Classify each gene as detected (1) or not (0) in each cell</span>
0172         cell_count_levels = sum(binary_levels,2); <span class="comment">% Number of cells expressing each transcript</span>
0173         cell_frac_levels = cell_count_levels/size(binary_levels,2); <span class="comment">% Number of cells expressing each transcript</span>
0174 
0175         <span class="comment">% Bin cell_frac_counts manually</span>
0176         x = 0:.01:1;
0177         <span class="keyword">for</span>(i = 1:length(x))
0178             cell_frac_count(i) = sum(round(cell_frac_levels,2)==x(i));
0179         <span class="keyword">end</span>
0180         
0181         <span class="comment">% Fit four beta distributions</span>
0182         cell_frac_count(cell_frac_count==0) = NaN; <span class="comment">% Remove zeros from optimization</span>
0183         cell_frac_count(1) = NaN; <span class="comment">% Remove non-expressed genes from optimization</span>
0184         x_lim = 1; <span class="comment">% Somewhat arbitrary parameter to fit left tail of distr.</span>
0185         myfun = @(par) nansum((cell_frac_count(1:find(x&gt;=x_lim,1)) - <span class="keyword">...</span>
0186             abs(par(1))*betapdf(x(1:find(x&gt;=x_lim,1)),abs(par(2)),abs(par(3))) - <span class="keyword">...</span>
0187             abs(par(4))*betapdf(x(1:find(x&gt;=x_lim,1)),abs(par(5)),abs(par(6))) - <span class="keyword">...</span>
0188             abs(par(7))*betapdf(x(1:find(x&gt;=x_lim,1)),abs(par(8)),abs(par(9))) - <span class="keyword">...</span>
0189             abs(par(10))*betapdf(x(1:find(x&gt;=x_lim,1)),abs(par(11)),abs(par(12)))).^2);
0190         
0191         par0 = [4,2,100,7,2,30,7,5,20,5,15,20];
0192         opts = optimset(<span class="string">'Display'</span>,<span class="string">'off'</span>);
0193         [par,f_val] = fminsearch(myfun,par0,opts);
0194         par = abs(par);
0195         
0196         <span class="comment">% Plot results</span>
0197         <span class="keyword">if</span> (isfield(arrayData,<span class="string">'plotResults'</span>))
0198             <span class="keyword">if</span> arrayData.plotResults == true
0199                 figure(); hold on; plot(x,cell_frac_count,<span class="string">'ko'</span>,<span class="string">'MarkerSize'</span>,5);
0200                 plot(x,abs(par(1))*betapdf(x,abs(par(2)),abs(par(3))),<span class="string">'b-'</span>,<span class="string">'LineWidth'</span>,1)
0201                 plot(x,abs(par(4))*betapdf(x,abs(par(5)),abs(par(6))),<span class="string">'b-'</span>,<span class="string">'LineWidth'</span>,1)
0202                 plot(x,abs(par(7))*betapdf(x,abs(par(8)),abs(par(9))),<span class="string">'b-'</span>,<span class="string">'LineWidth'</span>,1)
0203                 plot(x,abs(par(10))*betapdf(x,abs(par(11)),abs(par(12))),<span class="string">'b-'</span>,<span class="string">'LineWidth'</span>,1)
0204                 plot(x,abs(par(1))*betapdf(x,abs(par(2)),abs(par(3))) + <span class="keyword">...</span>
0205                     abs(par(4))*betapdf(x,abs(par(5)),abs(par(6))) + <span class="keyword">...</span>
0206                     abs(par(7))*betapdf(x,abs(par(8)),abs(par(9))) + <span class="keyword">...</span>
0207                     abs(par(10))*betapdf(x,abs(par(11)),abs(par(12))),<span class="string">'-'</span>,<span class="string">'Color'</span>,[.5 .5 .5],<span class="string">'LineWidth'</span>,2)
0208                 xlabel(<span class="string">'Expression Probability'</span>);ylabel(<span class="string">'# of genes'</span>);set(gca,<span class="string">'FontSize'</span>,14,<span class="string">'LineWidth'</span>,1.25);
0209                 title(<span class="string">'Expression prediction'</span>,<span class="string">'FontSize'</span>,18,<span class="string">'FontWeight'</span>,<span class="string">'bold'</span>)
0210             <span class="keyword">end</span>
0211         <span class="keyword">end</span>
0212         
0213         <span class="comment">% Score genes based on population expression (p = .05)</span>
0214         exprs_cutoff_1 = find(cdf(<span class="string">'beta'</span>,x,par(2),par(3)) &gt;.95,1)-1; <span class="comment">% Find index of no confidence genes</span>
0215         exprs_cutoff_2 = find(cdf(<span class="string">'beta'</span>,x,par(5),par(6)) &gt;.95,1)-1; <span class="comment">% Find index of low confidence genes</span>
0216         exprs_cutoff_3 = find(cdf(<span class="string">'beta'</span>,x,par(8),par(9)) &gt;.95,1)-1; <span class="comment">% Find index of low confidence genes</span>
0217         exprs_cutoffs = sort([exprs_cutoff_1,exprs_cutoff_2,exprs_cutoff_3]);
0218         gene_scores = cell_frac_levels*0;
0219         gene_scores(cell_frac_levels &lt;= x(exprs_cutoffs(1))) = 4; <span class="comment">% Not detected</span>
0220         gene_scores(logical((cell_frac_levels &gt;= x(exprs_cutoffs(1))).*(cell_frac_levels &lt; x(exprs_cutoffs(2))))) = 3; <span class="comment">% Low detection</span>
0221         gene_scores(logical((cell_frac_levels &gt;= x(exprs_cutoffs(2))).*(cell_frac_levels &lt; x(exprs_cutoffs(3))))) = 2; <span class="comment">% Medium detection</span>
0222         gene_scores(cell_frac_levels &gt; x(exprs_cutoffs(3))) = 1; <span class="comment">% High detection</span>
0223 
0224         <span class="comment">% Replace hpaData with singleCellData</span>
0225         <span class="keyword">if</span> printReport==true
0226             dispEM(<span class="string">'Single cell data is not currently compatible with HPA data. \n         Replacing hpaData with single cell-based scoring.'</span>,false);
0227         <span class="keyword">end</span>
0228         hpaData.genes = arrayData.genes;
0229         hpaData.tissues = arrayData.tissues;
0230         hpaData.celltypes = arrayData.celltypes;
0231         hpaData.levels = [{<span class="string">'High'</span>},{<span class="string">'Medium'</span>},{<span class="string">'Low'</span>},{<span class="string">'None'</span>}];
0232         hpaData.gene2Level = zeros(length(arrayData.genes),length(arrayData.celltypes));
0233         <span class="keyword">for</span> i = 1:length(find(J))
0234             find_var = find(J,i);
0235             hpaData.gene2Level(I,find_var(end)) = gene_scores;
0236         <span class="keyword">end</span>
0237         
0238         <span class="comment">% Remove arrayData from the analysis (Might be a bad idea)</span>
0239         clear arrayData
0240         arrayData=[];
0241     <span class="keyword">end</span>
0242 <span class="keyword">end</span>
0243 
0244 
0245 <span class="keyword">if</span> printReport==true
0246     <span class="keyword">if</span> any(celltype)
0247         fprintf([<span class="string">'***Generating model for: '</span> tissue <span class="string">' - '</span> celltype <span class="string">'\n'</span>]);
0248     <span class="keyword">else</span>
0249         fprintf([<span class="string">'***Generating model for: '</span> tissue <span class="string">'\n'</span>]);
0250     <span class="keyword">end</span>
0251     <span class="keyword">if</span> ~isempty(hpaData)
0252         fprintf(<span class="string">'-Using HPA data\n'</span>);
0253     <span class="keyword">end</span>
0254     <span class="keyword">if</span> ~isempty(arrayData)
0255         fprintf(<span class="string">'-Using array data\n'</span>);
0256     <span class="keyword">end</span>
0257     <span class="keyword">if</span> ~isempty(metabolomicsData)
0258         fprintf(<span class="string">'-Using metabolomics data\n'</span>);
0259     <span class="keyword">end</span>
0260     <span class="keyword">if</span> ~isempty(taskFile) || ~isempty(taskStructure)
0261         fprintf(<span class="string">'-Using metabolic tasks\n'</span>);
0262     <span class="keyword">end</span>
0263     fprintf(<span class="string">'\n'</span>);
0264     
0265     <a href="#_sub1" class="code" title="subfunction [rxnS, geneS]=printScores(model,name,hpaData,arrayData,tissue,celltype)">printScores</a>(refModel,<span class="string">'Reference model statistics'</span>,hpaData,arrayData,tissue,celltype);
0266 <span class="keyword">end</span>
0267 
0268 <span class="comment">%Remove dead-end reactions to speed up the optimization and to</span>
0269 <span class="comment">%differentiate between reactions removed by INIT and those that are</span>
0270 <span class="comment">%dead-end</span>
0271 [~, deletedDeadEndRxns]=simplifyModel(refModel,true,false,true,true,true);
0272 cModel=removeReactions(refModel,deletedDeadEndRxns,false,true);
0273 
0274 <span class="comment">%Store the connected model like this to keep track of stuff</span>
0275 <span class="keyword">if</span> printReport==true
0276     <a href="#_sub1" class="code" title="subfunction [rxnS, geneS]=printScores(model,name,hpaData,arrayData,tissue,celltype)">printScores</a>(cModel,<span class="string">'Pruned model statistics'</span>,hpaData,arrayData,tissue,celltype);
0277 <span class="keyword">end</span>
0278 
0279 <span class="comment">%If tasks have been defined, then go through them and get essential</span>
0280 <span class="comment">%reactions</span>
0281 <span class="keyword">if</span> ~isempty(taskStructure)
0282     [taskReport, essentialRxnMat]=checkTasks(cModel,[],printReport,true,true,taskStructure);
0283     
0284     essentialRxnsForTasks=cModel.rxns(any(essentialRxnMat,2));
0285     
0286     <span class="comment">%Remove tasks that cannot be performed</span>
0287     taskStructure(taskReport.ok==false)=[];
0288     <span class="keyword">if</span> printReport==true
0289         <a href="#_sub1" class="code" title="subfunction [rxnS, geneS]=printScores(model,name,hpaData,arrayData,tissue,celltype)">printScores</a>(removeReactions(cModel,setdiff(cModel.rxns,essentialRxnsForTasks),true,true),<span class="string">'Reactions essential for tasks'</span>,hpaData,arrayData,tissue,celltype);
0290     <span class="keyword">end</span>
0291 <span class="keyword">else</span>
0292     essentialRxnsForTasks={};
0293 <span class="keyword">end</span>
0294 
0295 <span class="comment">%Score the connected model</span>
0296 [rxnScores, geneScores]=scoreModel(cModel,hpaData,arrayData,tissue,celltype);
0297 
0298 <span class="comment">%Run the INIT algorithm. The exchange reactions that are used in the final</span>
0299 <span class="comment">%reactions will be open, which doesn't fit with the last step. Therefore</span>
0300 <span class="comment">%delete reactions from the original model instead of taking the output. The</span>
0301 <span class="comment">%default implementation does not constrain reversible reactions to only</span>
0302 <span class="comment">%carry flux in one direction. Runs without the constraints on reversibility</span>
0303 <span class="comment">%and with all output allowed. This is to reduce the complexity of the</span>
0304 <span class="comment">%problem.</span>
0305 [~, deletedRxnsInINIT, metProduction]=<a href="runINIT.html" class="code" title="function [outModel, deletedRxns, metProduction, fValue]=runINIT(model,rxnScores,presentMets,essentialRxns,prodWeight,allowExcretion,noRevLoops,params)">runINIT</a>(simplifyModel(cModel),rxnScores,metabolomicsData,essentialRxnsForTasks,0,true,false,params);
0306 initModel=removeReactions(cModel,deletedRxnsInINIT,true,true);
0307 <span class="keyword">if</span> printReport==true
0308     <a href="#_sub1" class="code" title="subfunction [rxnS, geneS]=printScores(model,name,hpaData,arrayData,tissue,celltype)">printScores</a>(initModel,<span class="string">'INIT model statistics'</span>,hpaData,arrayData,tissue,celltype);
0309     <a href="#_sub1" class="code" title="subfunction [rxnS, geneS]=printScores(model,name,hpaData,arrayData,tissue,celltype)">printScores</a>(removeReactions(cModel,setdiff(cModel.rxns,deletedRxnsInINIT),true,true),<span class="string">'Reactions deleted by INIT'</span>,hpaData,arrayData,tissue,celltype);
0310 <span class="keyword">end</span>
0311 
0312 <span class="comment">%The full model has exchange reactions in it. fitTasks calls on fillGaps,</span>
0313 <span class="comment">%which automatically removes exchange metabolites (because it assumes that</span>
0314 <span class="comment">%the reactions are constrained when appropriate). In this case the</span>
0315 <span class="comment">%uptakes/outputs are retrieved from the task sheet instead. To prevent</span>
0316 <span class="comment">%exchange reactions being used to fill gaps, they are delete from the</span>
0317 <span class="comment">%reference model here.</span>
0318 initModel.id=<span class="string">'INITModel'</span>;
0319 
0320 <span class="comment">%If gaps in the model should be filled using a task list</span>
0321 <span class="keyword">if</span> ~isempty(taskStructure)
0322     <span class="comment">%Remove exchange reactions and reactions already included in the INIT</span>
0323     <span class="comment">%model</span>
0324     refModelNoExc=removeReactions(refModel,union(initModel.rxns,getExchangeRxns(refModel)),true,true);
0325     
0326     <span class="comment">%At this stage the model is fully connected and most of the genes with</span>
0327     <span class="comment">%good scores should have been included. The final gap-filling should</span>
0328     <span class="comment">%take the scores of the genes into account, so that &quot;rather bad&quot;</span>
0329     <span class="comment">%reactions are preferred to &quot;very bad&quot; reactions. However, reactions</span>
0330     <span class="comment">%with positive scores will be included even if they are not connected</span>
0331     <span class="comment">%in the current formulation. Therefore, such reactions will have to be</span>
0332     <span class="comment">%assigned a small negative score instead.</span>
0333     <span class="keyword">if</span> useScoresForTasks==true
0334         refRxnScores=scoreModel(refModelNoExc,hpaData,arrayData,tissue,celltype);
0335         [outModel, addedRxnMat]=fitTasks(initModel,refModelNoExc,[],true,min(refRxnScores,-0.1),taskStructure,paramsFT);
0336     <span class="keyword">else</span>
0337         [outModel, addedRxnMat]=fitTasks(initModel,refModelNoExc,[],true,[],taskStructure,paramsFT);
0338     <span class="keyword">end</span>
0339     <span class="keyword">if</span> printReport==true
0340         <a href="#_sub1" class="code" title="subfunction [rxnS, geneS]=printScores(model,name,hpaData,arrayData,tissue,celltype)">printScores</a>(outModel,<span class="string">'Functional model statistics'</span>,hpaData,arrayData,tissue,celltype);
0341         <a href="#_sub1" class="code" title="subfunction [rxnS, geneS]=printScores(model,name,hpaData,arrayData,tissue,celltype)">printScores</a>(removeReactions(outModel,intersect(outModel.rxns,initModel.rxns),true,true),<span class="string">'Reactions added to perform the tasks'</span>,hpaData,arrayData,tissue,celltype);
0342     <span class="keyword">end</span>
0343     
0344     addedRxnsForTasks=refModelNoExc.rxns(any(addedRxnMat,2));
0345 <span class="keyword">else</span>
0346     outModel=initModel;
0347     addedRxnMat=[];
0348     addedRxnsForTasks={};
0349 <span class="keyword">end</span>
0350 
0351 <span class="comment">%The model can now perform all the tasks defined in the task list. The</span>
0352 <span class="comment">%algorithm cannot deal with gene-complexes at the moment. It is therefore</span>
0353 <span class="comment">%ok to remove bad genes from a reaction (as long as at least one gene is</span>
0354 <span class="comment">%kept)</span>
0355 model=outModel;
0356 
0357 [~, I]=ismember(model.genes,cModel.genes); <span class="comment">%All should be found</span>
0358 <span class="comment">%This is a little weird way to make sure that only one bad gene is included</span>
0359 <span class="comment">%if there are no good ones (since all -Inf==max(-Inf))</span>
0360 geneScores(isinf(geneScores))=-1000+rand(sum(isinf(geneScores)),1);
0361 
0362 model.grRules(:)={<span class="string">''</span>};
0363 <span class="keyword">for</span> i=1:numel(model.rxns)
0364     ids=find(model.rxnGeneMat(i,:));
0365     <span class="keyword">if</span> numel(ids)&gt;1
0366         scores=geneScores(I(ids));
0367         <span class="comment">%Only keep the positive ones if possible</span>
0368         model.rxnGeneMat(i,ids(~(scores&gt;0 | scores==max(scores))))=0;
0369     <span class="keyword">end</span>
0370     <span class="comment">%Rewrite the grRules to be only OR</span>
0371     <span class="keyword">if</span> isfield(model,<span class="string">'grRules'</span>)
0372         J=find(model.rxnGeneMat(i,:));
0373         <span class="keyword">for</span> j=1:numel(J)
0374             model.grRules{i}=[model.grRules{i} <span class="string">'('</span> model.genes{J(j)} <span class="string">')'</span>];
0375             <span class="keyword">if</span> j&lt;numel(J)
0376                 model.grRules{i}=[model.grRules{i} <span class="string">' or '</span>];
0377             <span class="keyword">end</span>
0378         <span class="keyword">end</span>
0379     <span class="keyword">end</span>
0380 <span class="keyword">end</span>
0381 
0382 <span class="comment">%Find all genes that are not used and delete them</span>
0383 I=sum(model.rxnGeneMat)==0;
0384 model.genes(I)=[];
0385 model.rxnGeneMat(:,I)=[];
0386 <span class="keyword">if</span> isfield(model,<span class="string">'geneShortNames'</span>)
0387     model.geneShortNames(I)=[];
0388 <span class="keyword">end</span>
0389 <span class="keyword">if</span> isfield(model,<span class="string">'geneMiriams'</span>)
0390     model.geneMiriams(I)=[];
0391 <span class="keyword">end</span>
0392 <span class="keyword">if</span> isfield(model,<span class="string">'geneFrom'</span>)
0393     model.geneFrom(I)=[];
0394 <span class="keyword">end</span>
0395 <span class="keyword">if</span> isfield(model,<span class="string">'geneComps'</span>)
0396     model.geneComps(I)=[];
0397 <span class="keyword">end</span>
0398 
0399 <span class="comment">%At this stage the model will contain some exchange reactions but probably</span>
0400 <span class="comment">%not all (and maybe zero). This can be inconvenient, so all exchange</span>
0401 <span class="comment">%reactions from the reference model are added, except for those which</span>
0402 <span class="comment">%involve metabolites that are not in the model.</span>
0403 
0404 <span class="comment">%First delete and included exchange reactions in order to prevent the order</span>
0405 <span class="comment">%from changing</span>
0406 model=removeReactions(model,getExchangeRxns(model));
0407 
0408 <span class="comment">%Create a model with only the exchange reactions in refModel</span>
0409 excModel=removeReactions(refModel,setdiff(refModel.rxns,getExchangeRxns(refModel)),true,true);
0410 
0411 <span class="comment">%Find the metabolites there which are not exchange metabolites and which do</span>
0412 <span class="comment">%not exist in the output model</span>
0413 I=~ismember(excModel.mets,model.mets) &amp; excModel.unconstrained==0;
0414 
0415 <span class="comment">%Then find those reactions and delete them</span>
0416 [~, J]=find(excModel.S(I,:));
0417 excModel=removeReactions(excModel,J,true,true);
0418 
0419 <span class="comment">%Merge with the output model</span>
0420 model=mergeModels({model;excModel},<span class="string">'metNames'</span>);
0421 model.id=<span class="string">'INITModel'</span>;
0422 model.description=[<span class="string">'Automatically generated model for '</span> tissue];
0423 <span class="keyword">if</span> any(celltype)
0424     model.description=[model.description <span class="string">' - '</span> celltype];
0425 <span class="keyword">end</span>
0426 
0427 <span class="keyword">if</span> printReport==true
0428     <a href="#_sub1" class="code" title="subfunction [rxnS, geneS]=printScores(model,name,hpaData,arrayData,tissue,celltype)">printScores</a>(model,<span class="string">'Final model statistics'</span>,hpaData,arrayData,tissue,celltype);
0429 <span class="keyword">end</span>
0430 
0431 <span class="comment">%Add information about essential reactions and reactions included for</span>
0432 <span class="comment">%gap-filling and return a taskReport</span>
0433 <span class="keyword">if</span> ~isempty(taskStructure)
0434     I=find(taskReport.ok); <span class="comment">%Ignore failed tasks</span>
0435     <span class="keyword">for</span> i=1:numel(I)
0436         taskReport.essential{I(i),1}=cModel.rxns(essentialRxnMat(:,I(i)));
0437         taskReport.gapfill{I(i),1}=refModelNoExc.rxns(addedRxnMat(:,i));
0438     <span class="keyword">end</span>
0439 <span class="keyword">else</span>
0440     taskReport=[];
0441 <span class="keyword">end</span>
0442 
0443 <span class="comment">%Fix grRules and reconstruct rxnGeneMat</span>
0444 [grRules,rxnGeneMat] = standardizeGrRules(model,true);
0445 model.grRules = grRules;
0446 model.rxnGeneMat = rxnGeneMat;
0447 <span class="keyword">end</span>
0448 
0449 <span class="comment">%This is for printing a summary of a model</span>
0450 <a name="_sub1" href="#_subfunctions" class="code">function [rxnS, geneS]=printScores(model,name,hpaData,arrayData,tissue,celltype)</a>
0451 [a, b]=scoreModel(model,hpaData,arrayData,tissue,celltype);
0452 rxnS=mean(a);
0453 geneS=mean(b(~isinf(b)));
0454 fprintf([name <span class="string">':\n'</span>]);
0455 fprintf([<span class="string">'\t'</span> num2str(numel(model.rxns)) <span class="string">' reactions, '</span> num2str(numel(model.genes)) <span class="string">' genes\n'</span>]);
0456 fprintf([<span class="string">'\tMean reaction score: '</span> num2str(rxnS) <span class="string">'\n'</span>]);
0457 fprintf([<span class="string">'\tMean gene score: '</span> num2str(geneS) <span class="string">'\n'</span>]);
0458 fprintf([<span class="string">'\tReactions with positive scores: '</span> num2str(100*sum(a&gt;0)/numel(a)) <span class="string">'%%\n\n'</span>]);
0459 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Wed 13-Jan-2021 21:53:20 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>